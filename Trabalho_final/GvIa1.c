#include <stdint.h>

#define VGA_BASE 0xC8000000
#define VGA_VISIBLE_COLS 320
#define VGA_PHYSICAL_COLS 512
#define VGA_ROWS 240

volatile uint16_t *ppix = (uint16_t *)VGA_BASE;

/*Lines*/
#define GREEN_D 0x03E0
#define GREEN_L 0x07C0
#define STRIPE_H 16

/*enemys*/
#define SQ_W 11
#define SQ_H 25

/*Dificulty*/
#define SCROLL_SPEED 1
#define MIN_SQ 1
#define MAX_SQ 3
#define MIN_GAP 60
#define MAX_GAP 70

/*RNG*/
static unsigned int rng_state = 1;
unsigned int rand32() { rng_state = rng_state * 1103515245 + 12345; return (rng_state>>16)&0x7FFF; }
int rand_range(int a,int b){ return a + (rand32()%(b-a+1)); }


/*Sprites*/
uint16_t enemy1_colors[][11] = {
    {0,0,0,0x0000,0x0000,0x0000,0x0000,0x0000,0,0,0},
    {0,0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0,0},
    {0,0x0000,0x0000,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x0000,0x0000,0},
    {0,0x0000,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x0000,0},
    {0,0x8A20,0x8A20,0x8A20,0x7D7F,0x8A20,0x7D7F,0x8A20,0x8A20,0x8A20,0},
    {0,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0x8A20,0},
    {0,0,0x8A20,0x8A20,0x8A20,0xF800,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0x8A20,0x8A20,0x8A20,0xF800,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0,0,0x8A20,0x8A20,0x8A20,0,0,0,0},
    {0,0xF800,0xF800,0xF800,0xFFFF,0xFFFF,0xFFFF,0xF800,0xF800,0xF800,0},
    {0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800},
    {0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800},
    {0xFFFF,0xFFFF,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFFFF,0xFFFF},
    {0x8A20,0x8A20,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0x8A20,0x8A20},
    {0x8A20,0x8A20,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0x8A20,0x8A20},
    {0x8A20,0x8A20,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0x8A20,0x8A20},
    {0x8A20,0x8A20,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0x8A20,0x8A20},
    {0,0x8A20,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8A20,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0x8A20,0x8A20,0x8A20,0,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0x8A20,0x8A20,0x8A20,0,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0x8A20,0x8A20,0x8A20,0,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0x8A20,0x8A20,0x8A20,0,0x8A20,0x8A20,0x8A20,0,0},
    {0,0,0xF800,0xF800,0xF800,0,0xF800,0xF800,0xF800,0,0},
};

uint16_t enemy2_colors[][11] = {
    {0,0,0,0x8A00,0x8A00,0x8A00,0x8A00,0x8A00,0,0,0},
    {0,0,0x8A00,0x8A00,0x8A00,0x8A00,0x8A00,0x8A00,0x8A00,0,0},
    {0,0x8A00,0x8A00,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0x8A00,0x8A00,0},
    {0,0x8A00,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0x8A00,0},
    {0,0xFDB7,0xFDB7,0xFDB7,0x05E0,0xFDB7,0x05E0,0xFDB7,0xFDB7,0xFDB7,0},
    {0,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0xFDB7,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0xF800,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0xF800,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0,0,0xFDB7,0xFDB7,0xFDB7,0,0,0,0},
    {0,0xF800,0xF800,0xF800,0xFFFF,0xFFFF,0xFFFF,0xF800,0xF800,0xF800,0},
    {0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800},
    {0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800},
    {0xFFFF,0xFFFF,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFFFF,0xFFFF},
    {0xFDB7,0xFDB7,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFDB7,0xFDB7},
    {0xFDB7,0xFDB7,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFDB7,0xFDB7},
    {0xFDB7,0xFDB7,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFDB7,0xFDB7},
    {0xFDB7,0xFDB7,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xFDB7,0xFDB7},
    {0,0xFDB7,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFDB7,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0xFFFF,0xFFFF,0xFFFF,0,0xFFFF,0xFFFF,0xFFFF,0,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0xFDB7,0xFDB7,0xFDB7,0,0xFDB7,0xFDB7,0xFDB7,0,0},
    {0,0,0,0x0000,0x0000,0,0x0000,0x0000,0x0000,0,0},
};

typedef struct {
    int y;
    int x;
    int type; /* 1 ou 2 */
} Enemy;

#define MAX_ACTIVE 200
Enemy enemies[MAX_ACTIVE];
int ecount = 0;

void draw_row_color(int y, uint16_t color)
{
    uint32_t base = y * VGA_PHYSICAL_COLS;
    for (int x = 0; x < VGA_VISIBLE_COLS; x++)
        ppix[base + x] = color;
}

void copy_row(int dst, int src)
{
    uint32_t bd = dst * VGA_PHYSICAL_COLS;
    uint32_t bs = src * VGA_PHYSICAL_COLS;
    for (int x = 0; x < VGA_VISIBLE_COLS; x++)
        ppix[bd + x] = ppix[bs + x];
}

void draw_sprite_partial(int y, int x, uint16_t sprite[][11])
{
    for (int r = 0; r < SQ_H; r++) {
        int yy = y + r;
        if (yy < 0) continue;
        if (yy >= VGA_ROWS) break;

        uint32_t base = yy * VGA_PHYSICAL_COLS;

        for (int c = 0; c < SQ_W; c++) {
            int xx = x + c;
            if (xx < 0 || xx >= VGA_VISIBLE_COLS) continue;
            uint16_t color = sprite[r][c];
            if (color)
                ppix[base + xx] = color;
        }
    }
}

void delay(){
    volatile int i;
    for(i=0;i<6000;i++);
}

/*colision*/

int conflict(int y, int x)
{
    for(int i=0;i<ecount;i++){
        int oy=enemies[i].y, ox=enemies[i].x;
        if ((y < oy + SQ_H + SQ_H) &&
            (y + SQ_H > oy - SQ_H) &&
            (x < ox + SQ_W + SQ_W) &&
            (x + SQ_W > ox - SQ_W))
            return 1;
    }
    return 0;
}

void cleanup()
{
    int j=0;
    for(int i=0;i<ecount;i++){
        if(enemies[i].y < VGA_ROWS)
            enemies[j++] = enemies[i];
    }
    ecount = j;
}

int main()
{
    int y;
    int next_spawn = rand_range(MIN_GAP,MAX_GAP);

    /*camp*/
    for(y=0;y<VGA_ROWS;y++){
        uint16_t color = ((y/STRIPE_H)&1) ? GREEN_D : GREEN_L;
        draw_row_color(y,color);
    }

    int stripe_pos = 0;
    int stripe_toggle = 0;

    while(1){

        /*scroll*/
        for(int s=0;s<SCROLL_SPEED;s++){
            for(y=VGA_ROWS-1;y>0;y--)
                copy_row(y,y-1);

            stripe_pos++;
            if(stripe_pos >= STRIPE_H){
                stripe_pos=0;
                stripe_toggle ^= 1;
            }

            draw_row_color(0, stripe_toggle ? GREEN_D : GREEN_L);
        }

        for(int i=0;i<ecount;i++)
            enemies[i].y += SCROLL_SPEED;

        cleanup();

        next_spawn -= SCROLL_SPEED;

        if(next_spawn <= 0){

            int qty = rand_range(MIN_SQ,MAX_SQ);
            int placed=0,attempts=0;
            int y0 = -SQ_H*2;

            while(placed<qty && attempts<200){
                attempts++;

                int x = rand_range(0, VGA_VISIBLE_COLS - SQ_W);

                if(!conflict(y0,x)){
                    if(ecount < MAX_ACTIVE){

                        enemies[ecount].x = x;
                        enemies[ecount].y = y0;
                        enemies[ecount].type = (rand32() & 1) ? 1 : 2;

                        if(enemies[ecount].type==1)
                            draw_sprite_partial(y0,x,enemy1_colors);
                        else
                            draw_sprite_partial(y0,x,enemy2_colors);

                        ecount++;
                        placed++;
                    }
                }
            }

            next_spawn = rand_range(MIN_GAP,MAX_GAP);
        }

        for(int i=0;i<ecount;i++){
            if(enemies[i].type==1)
                draw_sprite_partial(enemies[i].y, enemies[i].x, enemy1_colors);
            else
                draw_sprite_partial(enemies[i].y, enemies[i].x, enemy2_colors);
        }

        delay();
    }

    return 0;
}
